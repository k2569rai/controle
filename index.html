<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-Axis Vibration Logger & Analyzer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { background-color: #f0f2f5; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .canvas-container { 
            position: relative; 
            height: 30vh; /* スマホ縦画面で上下に並べても収まる高さ */
            width: 100%; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            margin-bottom: 10px;
        }
        .metric-box {
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .metric-value { font-size: 1.2rem; font-weight: bold; }
        .metric-label { font-size: 0.8rem; color: #666; }
        
        /* 軸の色定義 */
        .color-x { color: #dc3545; } /* Red */
        .color-y { color: #198754; } /* Green */
        .color-z { color: #0d6efd; } /* Blue */
        
        .btn-xl { padding: 10px 20px; font-size: 1.2rem; font-weight: bold; }
    </style>
</head>
<body>

<div class="container-fluid py-2">
    <div class="row mb-2">
        <div class="col-12">
            <h5 class="text-center mb-2 fw-bold">3-Axis Vibration Logger</h5>
            <div class="d-grid gap-2">
                <button id="btn-toggle" class="btn btn-primary btn-xl shadow-sm">Start Log</button>
                <button id="btn-download" class="btn btn-outline-dark shadow-sm" style="display:none;">CSV Download</button>
            </div>
            <div id="status" class="text-center small text-muted mt-1">Ready</div>
        </div>
    </div>

    <div class="row g-2 mb-2">
        <div class="col-4">
            <div class="metric-box border-bottom border-3 border-danger">
                <div class="metric-label">RMS (X)</div>
                <div id="rms-x" class="metric-value color-x">0.00</div>
            </div>
        </div>
        <div class="col-4">
            <div class="metric-box border-bottom border-3 border-success">
                <div class="metric-label">RMS (Y)</div>
                <div id="rms-y" class="metric-value color-y">0.00</div>
            </div>
        </div>
        <div class="col-4">
            <div class="metric-box border-bottom border-3 border-primary">
                <div class="metric-label">RMS (Z)</div>
                <div id="rms-z" class="metric-value color-z">0.00</div>
            </div>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="timeChart"></canvas>
    </div>

    <div class="card shadow-sm">
        <div class="card-header py-1 d-flex justify-content-between align-items-center bg-white">
            <small class="fw-bold">FFT Analysis</small>
            <div class="btn-group btn-group-sm" role="group">
                <input type="radio" class="btn-check" name="fft-axis" id="axis-x" value="x" autocomplete="off">
                <label class="btn btn-outline-danger" for="axis-x">X</label>

                <input type="radio" class="btn-check" name="fft-axis" id="axis-y" value="y" autocomplete="off">
                <label class="btn btn-outline-success" for="axis-y">Y</label>

                <input type="radio" class="btn-check" name="fft-axis" id="axis-z" value="z" autocomplete="off" checked>
                <label class="btn btn-outline-primary" for="axis-z">Z</label>
            </div>
        </div>
        <div class="canvas-container" style="height: 25vh; margin-bottom: 0;">
            <canvas id="freqChart"></canvas>
        </div>
        <div class="card-footer py-1 bg-white text-end">
             <span class="badge bg-secondary" id="peak-freq">Peak: -- Hz</span>
        </div>
    </div>
</div>

<script>
/**
 * 3軸振動解析・ロガーシステム
 */

// --- 設定 ---
const BUFFER_SIZE = 512;  // FFT解析窓サイズ
const TARGET_FREQ = 60;   // センサー周波数

// --- グローバル変数 ---
let isMeasuring = false;
let sensor = null;

// データバッファ（表示・解析用リングバッファ相当）
let displayData = { x: [], y: [], z: [], t: [] };
// 全データログ（CSV保存用）
let sessionLog = []; 

let timeChart, freqChart;
let fftSolver = null;

// --- FFT クラス (前回と同様の軽量実装) ---
class FastFourierTransform {
    constructor(size) {
        this.size = size;
        this.reverseTable = new Uint32Array(size);
        let limit = 1;
        let bit = size >> 1;
        while (limit < size) {
            for (let i = 0; i < limit; i++) {
                this.reverseTable[i + limit] = this.reverseTable[i] + bit;
            }
            limit <<= 1;
            bit >>= 1;
        }
        this.sinTable = new Float32Array(size);
        this.cosTable = new Float32Array(size);
        for (let i = 0; i < size; i++) {
            this.sinTable[i] = Math.sin(-Math.PI / i);
            this.cosTable[i] = Math.cos(-Math.PI / i);
        }
    }
    calculateSpectrum(realInput) {
        const n = this.size;
        const real = new Float32Array(n);
        const imag = new Float32Array(n);
        for (let i = 0; i < n; i++) {
            real[i] = realInput[this.reverseTable[i]];
            imag[i] = 0;
        }
        let halfSize = 1;
        while (halfSize < n) {
            const phaseShiftStepReal = this.cosTable[halfSize];
            const phaseShiftStepImag = this.sinTable[halfSize];
            let currentPhaseShiftReal = 1;
            let currentPhaseShiftImag = 0;
            for (let fftStep = 0; fftStep < halfSize; fftStep++) {
                for (let i = fftStep; i < n; i += 2 * halfSize) {
                    const off = i + halfSize;
                    const tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];
                    const ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];
                    real[off] = real[i] - tr;
                    imag[off] = imag[i] - ti;
                    real[i] += tr;
                    imag[i] += ti;
                }
                const tmpReal = currentPhaseShiftReal;
                currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;
                currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;
            }
            halfSize <<= 1;
        }
        const magnitudes = new Float32Array(n / 2);
        for (let i = 0; i < n / 2; i++) {
            magnitudes[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
        }
        return magnitudes;
    }
}

// --- 数学ユーティリティ ---
function calculateRMS(dataArray) {
    if (dataArray.length === 0) return 0;
    const sumSq = dataArray.reduce((sum, val) => sum + (val * val), 0);
    return Math.sqrt(sumSq / dataArray.length);
}

function removeDCOffset(data) {
    const mean = data.reduce((a, b) => a + b, 0) / data.length;
    return data.map(val => val - mean);
}

function applyHanningWindow(data) {
    const n = data.length;
    return data.map((val, i) => val * (0.5 * (1 - Math.cos((2 * Math.PI * i) / (n - 1)))));
}

// --- チャート初期化 ---
function initCharts() {
    fftSolver = new FastFourierTransform(BUFFER_SIZE);

    const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        elements: { point: { radius: 0 } },
        interaction: { mode: 'nearest', intersect: false },
        plugins: { legend: { labels: { boxWidth: 10 } } }
    };

    // 1. Time Domain Chart (3軸)
    const ctxTime = document.getElementById('timeChart').getContext('2d');
    timeChart = new Chart(ctxTime, {
        type: 'line',
        data: {
            labels: Array(BUFFER_SIZE).fill(''),
            datasets: [
                { label: 'X', data: [], borderColor: '#dc3545', borderWidth: 1.5, fill: false }, // Red
                { label: 'Y', data: [], borderColor: '#198754', borderWidth: 1.5, fill: false }, // Green
                { label: 'Z', data: [], borderColor: '#0d6efd', borderWidth: 1.5, fill: false }  // Blue
            ]
        },
        options: {
            ...commonOptions,
            scales: { 
                y: { title: { display: true, text: 'Accel (m/s²)' }, suggestMin: -2, suggestMax: 2 },
                x: { display: false } 
            }
        }
    });

    // 2. Frequency Domain Chart (選択された1軸)
    const ctxFreq = document.getElementById('freqChart').getContext('2d');
    freqChart = new Chart(ctxFreq, {
        type: 'bar',
        data: {
            labels: [],
            datasets: [{ label: 'Magnitude', data: [], backgroundColor: 'rgba(100, 100, 100, 0.7)' }]
        },
        options: {
            ...commonOptions,
            scales: { 
                x: { title: { display: true, text: 'Hz' }, ticks: { maxTicksLimit: 10 } },
                y: { beginAtZero: true, display: false }
            },
            plugins: { legend: { display: false } }
        }
    });
}

// --- メインループ処理 ---
function processData() {
    // 表示用バッファが満ちていなくても、現状のデータで更新する
    // ただしFFTはBUFFER_SIZE揃った時のみ行う
    
    // 1. RMS計算と表示更新 (直近のデータで計算)
    const currentX = displayData.x;
    const currentY = displayData.y;
    const currentZ = displayData.z;
    
    if (currentX.length > 0) {
        document.getElementById('rms-x').innerText = calculateRMS(currentX).toFixed(2);
        document.getElementById('rms-y').innerText = calculateRMS(currentY).toFixed(2);
        document.getElementById('rms-z').innerText = calculateRMS(currentZ).toFixed(2);
    }

    // 2. グラフ更新 (間引き処理はChart.jsがある程度やるが、データそのものを渡す)
    timeChart.data.datasets[0].data = currentX;
    timeChart.data.datasets[1].data = currentY;
    timeChart.data.datasets[2].data = currentZ;
    timeChart.update();

    // 3. FFT解析 (選択された軸のみ)
    if (currentX.length >= BUFFER_SIZE) {
        updateFFT();
        // バッファリセット (次のウィンドウへ)
        displayData.x = [];
        displayData.y = [];
        displayData.z = [];
        displayData.t = [];
    }
}

function updateFFT() {
    // 選択されている軸を取得
    const selectedAxis = document.querySelector('input[name="fft-axis"]:checked').value;
    let targetData = [];
    
    // 直前のBUFFER_SIZE分のデータを使用（リセット前）
    // 計測停止時などでデータが足りない場合はパディングするか、処理をスキップ
    if (displayData[selectedAxis].length < BUFFER_SIZE) return; 

    // バッファのコピーを作成
    targetData = displayData[selectedAxis].slice(0, BUFFER_SIZE);
    
    // 実効サンプリングレート計算
    const t = displayData.t;
    const durationSec = (t[t.length - 1] - t[0]) / 1000;
    const actualFs = (BUFFER_SIZE - 1) / durationSec || TARGET_FREQ;

    // 信号処理
    const detrended = removeDCOffset(targetData);
    const windowed = applyHanningWindow(detrended);
    const spectrum = fftSolver.calculateSpectrum(windowed);

    // グラフ用ラベル生成
    const freqBinWidth = actualFs / BUFFER_SIZE;
    const labels = [];
    let maxMag = 0;
    let peakFreq = 0;

    for(let i = 0; i < spectrum.length; i++) {
        const freq = i * freqBinWidth;
        labels.push(freq.toFixed(1));
        if (i > 1 && spectrum[i] > maxMag) { // DC無視
            maxMag = spectrum[i];
            peakFreq = freq;
        }
    }

    // FFTグラフ更新
    freqChart.data.labels = labels;
    freqChart.data.datasets[0].data = Array.from(spectrum);
    
    // 色を選択軸に合わせる
    const colorMap = { 'x': '#dc3545', 'y': '#198754', 'z': '#0d6efd' };
    freqChart.data.datasets[0].backgroundColor = colorMap[selectedAxis];
    freqChart.update();

    document.getElementById('peak-freq').innerText = `Peak: ${peakFreq.toFixed(1)} Hz`;
}

// --- センサー処理 ---
function handleSensorData(x, y, z, timestamp) {
    if (!isMeasuring) return;

    // 1. 全データのログ保存
    sessionLog.push({ t: timestamp, x: x, y: y, z: z });

    // 2. 表示・解析用バッファに追加
    displayData.x.push(x);
    displayData.y.push(y);
    displayData.z.push(z);
    displayData.t.push(timestamp);

    // バッファがいっぱいになったら処理を実行
    if (displayData.x.length >= BUFFER_SIZE) {
        processData();
    }
}

function startSensor() {
    // Android LinearAccelerationSensor
    if ('LinearAccelerationSensor' in window) {
        try {
            sensor = new LinearAccelerationSensor({ frequency: TARGET_FREQ });
            sensor.addEventListener('reading', () => {
                handleSensorData(sensor.x, sensor.y, sensor.z, performance.now());
            });
            sensor.addEventListener('error', (e) => {
                console.warn(e);
                useFallbackSensor();
            });
            sensor.start();
            return;
        } catch (e) {
            console.log("Sensor API failed, fallback.");
        }
    }
    useFallbackSensor();
}

function useFallbackSensor() {
    window.addEventListener('devicemotion', (event) => {
        const acc = event.acceleration;
        // fallbackの場合、nullチェックが必要
        const x = acc && acc.x != null ? acc.x : (event.accelerationIncludingGravity.x || 0);
        const y = acc && acc.y != null ? acc.y : (event.accelerationIncludingGravity.y || 0);
        const z = acc && acc.z != null ? acc.z : (event.accelerationIncludingGravity.z || 0);
        handleSensorData(x, y, z, performance.now());
    });
}

// --- CSV エクスポート ---
function downloadCSV() {
    if (sessionLog.length === 0) {
        alert("データがありません");
        return;
    }

    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "timestamp_ms,accel_x,accel_y,accel_z\n";

    // タイムスタンプを相対時間(0スタート)に変換
    const startTime = sessionLog[0].t;
    
    sessionLog.forEach(row => {
        const relativeTime = (row.t - startTime).toFixed(3);
        csvContent += `${relativeTime},${row.x.toFixed(4)},${row.y.toFixed(4)},${row.z.toFixed(4)}\n`;
    });

    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    
    // 現在時刻でファイル名生成
    const now = new Date();
    const filename = `vibration_log_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.csv`;
    link.setAttribute("download", filename);
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// --- UI イベント ---
document.getElementById('btn-toggle').addEventListener('click', function() {
    const btn = this;
    const downloadBtn = document.getElementById('btn-download');
    
    if (isMeasuring) {
        // --- 停止処理 ---
        isMeasuring = false;
        if(sensor) sensor.stop();
        
        btn.innerText = "Start Log";
        btn.classList.replace('btn-danger', 'btn-primary');
        document.getElementById('status').innerText = `計測終了: ${sessionLog.length} ポイント記録済み`;
        
        // 最後のバッファが残っていればFFT更新してグラフに残す
        if (displayData.x.length > 32) { // ある程度のデータがあれば
             updateFFT();
             timeChart.update();
        }

        downloadBtn.style.display = 'block'; // DLボタン表示
        
    } else {
        // --- 開始処理 ---
        sessionLog = []; // ログリセット
        displayData = { x: [], y: [], z: [], t: [] }; // 表示バッファリセット
        
        isMeasuring = true;
        btn.innerText = "Stop & Analyze";
        btn.classList.replace('btn-primary', 'btn-danger');
        downloadBtn.style.display = 'none';
        document.getElementById('status').innerText = "計測・ロギング中...";
        
        if (!sensor && !window.ondevicemotion) {
            startSensor();
        } else if (sensor) {
            sensor.start();
        }
    }
});

document.getElementById('btn-download').addEventListener('click', downloadCSV);

// ラジオボタン切り替え時に、データが残っていればFFTを再描画（停止後の分析用）
document.querySelectorAll('input[name="fft-axis"]').forEach(radio => {
    radio.addEventListener('change', () => {
        // 現在のバッファにデータがあれば再描画
        if (displayData.x.length > 0) {
            updateFFT();
        }
    });
});

initCharts();

</script>
</body>
</html>