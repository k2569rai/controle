<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vib-Lab v5.0 Ultimate</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { background-color: #f0f2f5; font-family: monospace; touch-action: manipulation; }
        .canvas-container { position: relative; width: 100%; background: white; border-radius: 8px; border: 1px solid #ddd; overflow: hidden; }
        .status-badge { font-size: 0.8rem; padding: 0.4em 0.8em; border-radius: 20px; color: white; transition: 0.3s; }
        .bg-idle { background-color: #6c757d; }
        .bg-armed { background-color: #ffc107; color: black; }
        .bg-rec { background-color: #dc3545; animation: pulse 1s infinite; }
        .bg-review { background-color: #0d6efd; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
        
        /* Spectrogram specific */
        #spectroCanvas { width: 100%; height: 100%; background: black; }
        
        /* Analysis Result Box */
        .analysis-box { background: #e8f4f8; border-left: 5px solid #0d6efd; padding: 10px; margin-top: 10px; font-size: 0.9rem; display: none; }
    </style>
</head>
<body>

<div class="container py-2" style="max-width: 600px;">
    <div class="d-flex justify-content-between align-items-center mb-2">
        <h6 class="fw-bold m-0">Vib-Lab <span class="badge bg-dark">v5.0</span></h6>
        <span id="status-display" class="status-badge bg-idle">MONITOR</span>
    </div>

    <div class="card p-2 mb-2">
        <div class="d-flex justify-content-between align-items-center mb-1">
            <div class="btn-group btn-group-sm w-50" role="group">
                <input type="radio" class="btn-check" name="filter" id="fRaw" onchange="setFilter('RAW')">
                <label class="btn btn-outline-secondary" for="fRaw">RAW</label>
                <input type="radio" class="btn-check" name="filter" id="fHPF" checked onchange="setFilter('HPF')">
                <label class="btn btn-outline-dark" for="fHPF">HPF</label>
            </div>
            <div class="small text-end w-50">
                <span class="text-muted">RMS(Z): </span><span id="rms-val" class="fw-bold text-primary">0.00</span>
            </div>
        </div>
        <div class="row g-1">
             <div class="col-4"><button id="btn-arm" class="btn btn-warning w-100 btn-sm fw-bold">ARM (Pre)</button></div>
             <div class="col-4"><button id="btn-stop" class="btn btn-secondary w-100 btn-sm d-none">STOP</button></div>
             <div class="col-4"><button id="btn-dl" class="btn btn-success w-100 btn-sm" disabled>CSV</button></div>
        </div>
    </div>

    <ul class="nav nav-tabs nav-fill mb-2" id="myTab" role="tablist">
        <li class="nav-item"><button class="nav-link active py-1" id="main-tab" data-bs-toggle="tab" data-bs-target="#main" type="button">Wave & FFT</button></li>
        <li class="nav-item"><button class="nav-link py-1" id="spectro-tab" data-bs-toggle="tab" data-bs-target="#spectro" type="button">Spectrogram</button></li>
    </ul>

    <div class="tab-content" id="myTabContent">
        <div class="tab-pane fade show active" id="main" role="tabpanel">
            <div class="canvas-container mb-1" style="height: 20vh;">
                <canvas id="timeChart"></canvas>
            </div>
            <div class="d-flex justify-content-between px-1 small text-muted">
                <span>FFT (Z-Axis)</span>
                <span>Peak: <span id="peak-freq" class="fw-bold text-dark">--</span> Hz</span>
            </div>
            <div class="canvas-container" style="height: 18vh;">
                <canvas id="freqChart"></canvas>
            </div>
            
            <div id="analysis-result" class="analysis-box">
                <strong>Analysis Result:</strong><br>
                Zeta (Î¶): <span id="res-zeta" class="fw-bold">--</span> (Damping Ratio)<br>
                Fn: <span id="res-fn" class="fw-bold">--</span> Hz (Natural Freq)
            </div>
        </div>

        <div class="tab-pane fade" id="spectro" role="tabpanel">
            <div class="canvas-container" style="height: 40vh; background: black;">
                <canvas id="spectroCanvas"></canvas>
            </div>
            <div class="text-center small text-muted mt-1">Time (Scrolls Down) &darr; | Freq (L to R) &rarr;</div>
        </div>
    </div>
</div>

<script>
/**
 * Vib-Lab v5.0 Ultimate
 * Features: HPF, Pre-Trigger, Spectrogram, Auto-Damping Calculation
 */

// --- Constants ---
const FS = 60;          // Sampling Rate
const BUFFER_SIZE = 256;
const PRE_TRIGGER_SEC = 0.5; // 0.5 sec pre-recording
const REC_DURATION_SEC = 3.0; // Short duration for impact test
const PRE_BUFFER_LEN = Math.ceil(PRE_TRIGGER_SEC * FS);

// --- State ---
let state = 'IDLE'; // IDLE, ARMED, RECORDING, REVIEW
let filterMode = 'HPF';
let offsets = {x:0, y:0, z:0};
let displayBuf = {x:[], y:[], z:[]};
let ringBuffer = []; // For Pre-Trigger (always running)
let recordBuffer = []; // For Saving & Analysis
let recStartTime = 0;
let lastDraw = 0;

// --- DSP Objects ---
class Filter {
    constructor() { this.reset(); }
    reset() { 
        this.prevIn = {x:0, y:0, z:0}; 
        this.prevOut = {x:0, y:0, z:0};
        const rc = 1.0 / (2 * Math.PI * 1.0); // fc=1Hz
        this.alpha = rc / (rc + (1/FS));
    }
    process(x, y, z) {
        if(filterMode === 'RAW') return {x, y, z};
        // HPF Logic
        const out = {};
        out.x = this.alpha * (this.prevOut.x + x - this.prevIn.x);
        out.y = this.alpha * (this.prevOut.y + y - this.prevIn.y);
        out.z = this.alpha * (this.prevOut.z + z - this.prevIn.z);
        this.prevIn = {x,y,z}; this.prevOut = out;
        return out;
    }
}
const filter = new Filter();

class FFT {
    constructor(n) {
        this.n = n; this.rev = new Uint32Array(n); this.sin = new Float32Array(n); this.cos = new Float32Array(n);
        let lim=1, bit=n>>1;
        while(lim<n){ for(let i=0;i<lim;i++) this.rev[i+lim]=this.rev[i]+bit; lim<<=1; bit>>=1; }
        for(let i=0;i<n;i++){ this.sin[i]=Math.sin(-Math.PI/i); this.cos[i]=Math.cos(-Math.PI/i); }
    }
    calc(input) {
        const n=this.n, real=new Float32Array(n), imag=new Float32Array(n);
        for(let i=0;i<n;i++){ real[i]=input[this.rev[i]]; imag[i]=0; }
        let h=1;
        while(h<n) {
            const wr=this.cos[h], wi=this.sin[h];
            let cr=1, ci=0;
            for(let s=0;s<h;s++) {
                for(let i=s;i<n;i+=2*h) {
                    const off=i+h; const tr=cr*real[off]-ci*imag[off]; const ti=cr*imag[off]+ci*real[off];
                    real[off]=real[i]-tr; imag[off]=imag[i]-ti; real[i]+=tr; imag[i]+=ti;
                }
                const tr=cr; cr=tr*wr-ci*wi; ci=tr*wi+ci*wr;
            }
            h<<=1;
        }
        const mag=new Float32Array(n/2);
        for(let i=0;i<n/2;i++) mag[i]=Math.sqrt(real[i]*real[i]+imag[i]*imag[i]);
        return mag;
    }
}
const fft = new FFT(BUFFER_SIZE);

// --- Charts & Canvases ---
const commonOpts = { responsive: true, maintainAspectRatio: false, animation: false, elements: {point:{radius:0}}, plugins:{legend:{display:false}}, scales:{x:{display:false}, y:{display:true}} };
const timeChart = new Chart(document.getElementById('timeChart'), { type:'line', data:{labels:Array(BUFFER_SIZE).fill(''), datasets:[{data:[], borderColor:'#0d6efd', borderWidth:1}]}, options:{...commonOpts, scales:{y:{min:-5, max:5}}} });
const freqChart = new Chart(document.getElementById('freqChart'), { type:'bar', data:{labels:[], datasets:[{data:[], backgroundColor:'#6c757d'}]}, options:{...commonOpts, scales:{x:{display:true}, y:{display:false}}} });

// Spectrogram Canvas
const spCanvas = document.getElementById('spectroCanvas');
const spCtx = spCanvas.getContext('2d');
let spWidth, spHeight;
function resizeSpectro() {
    spWidth = spCanvas.parentElement.clientWidth;
    spHeight = spCanvas.parentElement.clientHeight;
    spCanvas.width = spWidth; spCanvas.height = spHeight;
    spCtx.fillStyle = 'black'; spCtx.fillRect(0,0,spWidth,spHeight);
}
window.addEventListener('resize', resizeSpectro);
setTimeout(resizeSpectro, 500);

// --- Main Loop ---
function handleData(rawX, rawY, rawZ, t) {
    if(state === 'REVIEW') return;

    // 1. Filter
    const val = filter.process(rawX, rawY, rawZ);
    const z = val.z; // Mainly analyze Z

    // 2. Ring Buffer (Pre-Trigger)
    ringBuffer.push({t, x:val.x, y:val.y, z:val.z});
    if(ringBuffer.length > PRE_BUFFER_LEN * 2) ringBuffer.shift();

    // 3. Display Buffer
    displayBuf.z.push(z);
    if(displayBuf.z.length > BUFFER_SIZE) displayBuf.z.shift();

    if(Math.random()<0.1) document.getElementById('rms-val').innerText = Math.abs(z).toFixed(2);

    // 4. Trigger Logic
    if(state === 'ARMED') {
        if(Math.abs(z) > 1.5) { // Threshold
            startRecording(t);
        }
    }
    if(state === 'RECORDING') {
        recordBuffer.push({t, x:val.x, y:val.y, z:val.z});
        if((t - recStartTime) > REC_DURATION_SEC * 1000) {
            finishRecording();
        }
    }

    // 5. Drawing (approx 15fps)
    if(t - lastDraw > 60) {
        drawCharts();
        drawSpectrogram(displayBuf.z);
        lastDraw = t;
    }
}

function startRecording(t) {
    state = 'RECORDING';
    recStartTime = t;
    updateStatus('RECORDING', 'bg-rec');
    
    // Copy Pre-Trigger Data
    const cutIdx = Math.max(0, ringBuffer.length - PRE_BUFFER_LEN);
    recordBuffer = ringBuffer.slice(cutIdx); // Copy last 0.5s
}

function finishRecording() {
    state = 'REVIEW';
    updateStatus('ANALYZING...', 'bg-review');
    document.getElementById('btn-stop').classList.add('d-none');
    document.getElementById('btn-arm').classList.remove('d-none');
    document.getElementById('btn-arm').innerText = "RESET / ARM";
    document.getElementById('btn-dl').disabled = false;
    
    analyzeDamping();
}

function analyzeDamping() {
    // Simple Peak Detection & Log Decrement
    const data = recordBuffer.map(d => d.z);
    // Find absolute peaks
    let peaks = [];
    for(let i=1; i<data.length-1; i++) {
        if(data[i] > 0.5 && data[i] > data[i-1] && data[i] > data[i+1]) {
            peaks.push({i, val: data[i]});
        }
    }
    
    // Calculate if we have at least 2 peaks
    if(peaks.length >= 2) {
        const p1 = peaks[0];
        const p2 = peaks[1];
        const delta = Math.log(p1.val / p2.val); // Logarithmic Decrement
        const zeta = delta / Math.sqrt(4 * Math.PI**2 + delta**2); // Damping Ratio
        const period = (recordBuffer[p2.i].t - recordBuffer[p1.i].t) / 1000;
        const fn = 1 / period;

        document.getElementById('res-zeta').innerText = zeta.toFixed(4);
        document.getElementById('res-fn').innerText = fn.toFixed(1);
        document.getElementById('analysis-result').style.display = 'block';
    } else {
        document.getElementById('analysis-result').innerText = "Analysis Failed: Clear peaks not found.";
        document.getElementById('analysis-result').style.display = 'block';
    }
}

function drawCharts() {
    timeChart.data.datasets[0].data = displayBuf.z;
    timeChart.update();

    if(displayBuf.z.length >= BUFFER_SIZE) {
        const win = displayBuf.z.map((v, i) => v * (0.5 * (1 - Math.cos(2*Math.PI*i/(BUFFER_SIZE-1)))));
        const spec = fft.calc(win);
        const labels=[], data=[];
        let maxV=0, peak=0;
        const bin = FS/BUFFER_SIZE;
        for(let i=0; i<32; i++) { // Show up to ~8Hz (Low Freq Focus) or more
             const f = i*bin; labels.push(f.toFixed(1)); data.push(spec[i]);
             if(i>2 && spec[i]>maxV) { maxV=spec[i]; peak=f; }
        }
        freqChart.data.labels = labels;
        freqChart.data.datasets[0].data = data;
        freqChart.update();
        document.getElementById('peak-freq').innerText = peak.toFixed(1);
    }
}

// Spectrogram Logic (Waterfall)
function drawSpectrogram(buffer) {
    if(document.getElementById('spectro-tab').getAttribute('aria-selected') !== 'true') return;
    if(buffer.length < BUFFER_SIZE) return;

    const win = buffer.map((v, i) => v * (0.5 * (1 - Math.cos(2*Math.PI*i/(BUFFER_SIZE-1)))));
    const spec = fft.calc(win);
    
    // Shift image down
    const imgData = spCtx.getImageData(0, 0, spWidth, spHeight - 1);
    spCtx.putImageData(imgData, 0, 1);

    // Draw new line at top
    const binWidth = spWidth / 30; // Display first 30 bins
    for(let i=0; i<30; i++) {
        const mag = spec[i] * 5; // Gain
        const val = Math.min(255, mag * 50);
        spCtx.fillStyle = `rgb(${val}, ${255-val}, 50)`; // Heatmap color
        spCtx.fillRect(i * binWidth, 0, binWidth, 1);
    }
}

// --- UI Actions ---
function updateStatus(txt, cls) {
    const el = document.getElementById('status-display');
    el.innerText = txt; el.className = `status-badge ${cls}`;
}
function setFilter(m) { filterMode = m; filter.reset(); }

document.getElementById('btn-arm').addEventListener('click', () => {
    state = 'ARMED';
    ringBuffer = []; recordBuffer = [];
    document.getElementById('analysis-result').style.display = 'none';
    updateStatus('ARMED (Hit me!)', 'bg-armed');
    document.getElementById('btn-arm').classList.add('d-none');
    document.getElementById('btn-stop').classList.remove('d-none');
    document.getElementById('btn-dl').disabled = true;
});

document.getElementById('btn-stop').addEventListener('click', () => {
    state = 'IDLE';
    updateStatus('MONITOR', 'bg-idle');
    document.getElementById('btn-stop').classList.add('d-none');
    document.getElementById('btn-arm').classList.remove('d-none');
    document.getElementById('btn-arm').innerText = "ARM (Pre)";
});

document.getElementById('btn-dl').addEventListener('click', () => {
    let csv = "Time,X,Y,Z\n" + recordBuffer.map(d => `${d.t},${d.x},${d.y},${d.z}`).join("\n");
    const a = document.createElement("a");
    a.href = encodeURI("data:text/csv;charset=utf-8," + csv);
    a.download = "vib_ultimate.csv";
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
});

// --- Sensor ---
function initSensor() {
    if ('LinearAccelerationSensor' in window) {
        try {
            const s = new LinearAccelerationSensor({frequency: FS});
            s.addEventListener('reading', () => handleData(s.x, s.y, s.z, performance.now()));
            s.start();
        } catch(e){ fallback(); }
    } else { fallback(); }
}
function fallback() {
    window.addEventListener('devicemotion', e => {
        const acc = e.acceleration || e.accelerationIncludingGravity;
        handleData(acc.x||0, acc.y||0, acc.z||0, performance.now());
    });
}
initSensor();

</script>
</body>
</html>