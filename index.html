<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Vibration Lab v3.3</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { background-color: #f0f2f5; font-family: 'Helvetica Neue', Arial, sans-serif; touch-action: manipulation; }
        .canvas-container { position: relative; height: 28vh; width: 100%; margin-bottom: 0.5rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .rms-value { font-size: 1.1rem; font-weight: bold; font-family: monospace;}
        .status-badge { font-size: 0.9rem; padding: 0.5em 1em; border-radius: 20px; display: inline-block; width: 100%; transition: background-color 0.3s; }
        
        /* Status Colors */
        .bg-idle { background-color: #6c757d; color: white; }
        .bg-waiting { background-color: #ffc107; color: #000; }
        .bg-recording { background-color: #dc3545; color: white; animation: pulse 1.5s infinite; }
        .bg-review { background-color: #0d6efd; color: white; } /* 青色：確認中 */

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        .control-panel { background: white; padding: 15px; border-radius: 12px; margin-bottom: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    </style>
</head>
<body>

<div class="container py-2">
    <h5 class="text-center fw-bold mb-3">Vibration Lab <span class="badge bg-dark">v3.3 (Freeze)</span></h5>

    <div class="mb-2 text-center">
        <span id="status-display" class="status-badge bg-idle">MONITORING</span>
    </div>

    <div class="control-panel">
        <div class="row text-center mb-3">
            <div class="col-4 border-end">
                <small class="text-muted d-block">X (RMS)</small>
                <span id="rms-x" class="rms-value text-danger">0.00</span>
            </div>
            <div class="col-4 border-end">
                <small class="text-muted d-block">Y (RMS)</small>
                <span id="rms-y" class="rms-value text-success">0.00</span>
            </div>
            <div class="col-4">
                <small class="text-muted d-block">Z (RMS)</small>
                <span id="rms-z" class="rms-value text-primary">0.00</span>
            </div>
        </div>

        <div class="row g-2 align-items-center mb-3">
            <div class="col-6">
                <label class="small text-muted">Threshold</label>
                <div class="input-group input-group-sm">
                    <input type="number" id="trigger-threshold" class="form-control" value="2.0" step="0.5">
                    <span class="input-group-text">m/s²</span>
                </div>
            </div>
            <div class="col-6">
                <label class="small text-muted">Duration</label>
                <div class="input-group input-group-sm">
                    <input type="number" id="record-duration" class="form-control" value="5" step="1">
                    <span class="input-group-text">sec</span>
                </div>
            </div>
        </div>

        <div class="row g-2">
            <div class="col-6">
                <button id="btn-calibrate" class="btn btn-outline-dark w-100 btn-sm">Zero Calibrate</button>
            </div>
            <div class="col-6">
                <button id="btn-download" class="btn btn-success w-100 btn-sm" disabled>Save CSV</button>
            </div>
            <div class="col-12 mt-2">
                <button id="btn-trigger-start" class="btn btn-primary w-100 fw-bold py-2">
                    Start (Trigger Mode)
                </button>
                <button id="btn-reset" class="btn btn-secondary w-100 fw-bold py-2 d-none">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="timeChart"></canvas>
    </div>
    
    <div class="d-flex justify-content-between align-items-center mb-1 px-2">
        <span class="small text-muted">FFT Axis</span>
        <div class="btn-group btn-group-sm" role="group">
            <input type="radio" class="btn-check" name="fftAxis" id="axisX" onchange="changeAxis('x')">
            <label class="btn btn-outline-danger" for="axisX">X</label>
            <input type="radio" class="btn-check" name="fftAxis" id="axisY" onchange="changeAxis('y')">
            <label class="btn btn-outline-success" for="axisY">Y</label>
            <input type="radio" class="btn-check" name="fftAxis" id="axisZ" checked onchange="changeAxis('z')">
            <label class="btn btn-outline-primary" for="axisZ">Z</label>
        </div>
    </div>
    
    <div class="canvas-container">
        <canvas id="freqChart"></canvas>
    </div>
    <div class="text-center small text-muted mt-1">Peak: <span id="peak-freq" class="fw-bold">--</span> Hz</div>
</div>

<script>
/**
 * v3.3: Freeze Mode Implementation
 * 録音終了時に描画を停止し、結果を確認可能にする
 */

// --- Constants ---
const BUFFER_SIZE = 256;
const TARGET_FREQ = 60;

// --- State Variables ---
let state = 'IDLE'; // 'IDLE', 'ARMED', 'RECORDING', 'REVIEW' (New!)
let offsets = { x: 0, y: 0, z: 0 };
let displayBuffer = { x: [], y: [], z: [] };
let recordBuffer = [];
let recStartTime = 0;
let recDurationMs = 5000;
let triggerThresh = 2.0;
let currentAxis = 'z';

// --- FFT Logic ---
class FFT {
    constructor(n) {
        this.n = n;
        this.rev = new Uint32Array(n);
        this.sin = new Float32Array(n);
        this.cos = new Float32Array(n);
        let lim = 1, bit = n >> 1;
        while (lim < n) {
            for (let i = 0; i < lim; i++) this.rev[i + lim] = this.rev[i] + bit;
            lim <<= 1; bit >>= 1;
        }
        for (let i = 0; i < n; i++) {
            this.sin[i] = Math.sin(-Math.PI / i);
            this.cos[i] = Math.cos(-Math.PI / i);
        }
    }
    calc(input) {
        const n = this.n, real = new Float32Array(n), imag = new Float32Array(n);
        for (let i = 0; i < n; i++) { real[i] = input[this.rev[i]]; imag[i] = 0; }
        let h = 1;
        while (h < n) {
            const wr = this.cos[h], wi = this.sin[h];
            let cr = 1, ci = 0;
            for (let s = 0; s < h; s++) {
                for (let i = s; i < n; i += 2 * h) {
                    const off = i + h;
                    const tr = cr * real[off] - ci * imag[off];
                    const ti = cr * imag[off] + ci * real[off];
                    real[off] = real[i] - tr; imag[off] = imag[i] - ti;
                    real[i] += tr; imag[i] += ti;
                }
                const tr = cr; cr = tr * wr - ci * wi; ci = tr * wi + ci * wr;
            }
            h <<= 1;
        }
        const mag = new Float32Array(n/2);
        for(let i=0; i<n/2; i++) mag[i] = Math.sqrt(real[i]*real[i] + imag[i]*imag[i]);
        return mag;
    }
}
const fft = new FFT(BUFFER_SIZE);

// --- Charts ---
const commonOpts = { 
    responsive: true, maintainAspectRatio: false, animation: false, 
    elements: { point: { radius: 0 } }, plugins: { legend: { display: false } },
    scales: { x: { display: false }, y: { display: true } }
};

const timeChart = new Chart(document.getElementById('timeChart'), {
    type: 'line',
    data: { labels: Array(BUFFER_SIZE).fill(''), datasets: [
        { data: [], borderColor: '#dc3545', borderWidth: 1 },
        { data: [], borderColor: '#198754', borderWidth: 1 },
        { data: [], borderColor: '#0d6efd', borderWidth: 1 }
    ]},
    options: { ...commonOpts, scales: { y: { min: -10, max: 10 } } }
});

const freqChart = new Chart(document.getElementById('freqChart'), {
    type: 'bar',
    data: { labels: [], datasets: [{ data: [], backgroundColor: '#0d6efd' }] },
    options: { ...commonOpts, scales: { x: { display: true }, y: { display: false } } }
});

// --- Main Processing Loop ---
let lastChartUpdate = 0;

function handleSensorData(rawX, rawY, rawZ, t) {
    // 【重要】REVIEWモード中はセンサー入力を無視して画面をフリーズさせる
    if (state === 'REVIEW') return;

    // 1. Calibration
    const x = rawX - offsets.x;
    const y = rawY - offsets.y;
    const z = rawZ - offsets.z;

    // 2. Display Buffer (Circular)
    displayBuffer.x.push(x);
    displayBuffer.y.push(y);
    displayBuffer.z.push(z);
    if (displayBuffer.x.length > BUFFER_SIZE) {
        displayBuffer.x.shift(); displayBuffer.y.shift(); displayBuffer.z.shift();
    }

    // 3. RMS & Logic
    if (Math.random() < 0.1) {
        document.getElementById('rms-x').innerText = Math.abs(x).toFixed(2);
        document.getElementById('rms-y').innerText = Math.abs(y).toFixed(2);
        document.getElementById('rms-z').innerText = Math.abs(z).toFixed(2);
    }

    if (state === 'ARMED') {
        if (Math.abs(x) > triggerThresh || Math.abs(y) > triggerThresh || Math.abs(z) > triggerThresh) {
            state = 'RECORDING';
            recStartTime = t;
            recordBuffer = []; 
            updateStatusUI();
        }
    }

    if (state === 'RECORDING') {
        recordBuffer.push([t, x, y, z]);
        
        // --- 録音終了時の処理 ---
        if ((t - recStartTime) > recDurationMs) {
            state = 'REVIEW'; // ここでフリーズモードへ移行
            updateStatusUI();
            
            // 念のため最後に一回描画して最新状態にする
            drawCharts();
            document.getElementById('btn-download').disabled = false;
            return; 
        }
    }

    // 4. Draw Charts (Limit FPS)
    if (t - lastChartUpdate > 50) {
        drawCharts();
        lastChartUpdate = t;
    }
}

function drawCharts() {
    timeChart.data.datasets[0].data = displayBuffer.x;
    timeChart.data.datasets[1].data = displayBuffer.y;
    timeChart.data.datasets[2].data = displayBuffer.z;
    timeChart.update();

    const src = displayBuffer[currentAxis];
    if (src.length >= BUFFER_SIZE) {
        const win = src.map((v, i) => v * (0.5 * (1 - Math.cos(2*Math.PI*i/(BUFFER_SIZE-1)))));
        const spec = fft.calc(win);
        
        const labels = [], data = [];
        let maxV = 0, peak = 0;
        const bin = TARGET_FREQ / BUFFER_SIZE;
        
        for (let i = 0; i < spec.length; i++) {
            const f = i * bin;
            if (f > 30) break; 
            labels.push(f.toFixed(1));
            data.push(spec[i]);
            if (i > 2 && spec[i] > maxV) { maxV = spec[i]; peak = f; }
        }
        
        freqChart.data.labels = labels;
        freqChart.data.datasets[0].data = data;
        freqChart.data.datasets[0].backgroundColor = (currentAxis==='x'?'#dc3545':(currentAxis==='y'?'#198754':'#0d6efd'));
        freqChart.update();
        document.getElementById('peak-freq').innerText = peak.toFixed(1);
    }
}

// --- UI Actions ---
function updateStatusUI() {
    const badge = document.getElementById('status-display');
    const btnStart = document.getElementById('btn-trigger-start');
    const btnReset = document.getElementById('btn-reset');

    if (state === 'IDLE') {
        badge.innerText = "MONITORING (Idle)";
        badge.className = "status-badge bg-idle";
        btnStart.classList.remove('d-none');
        btnStart.innerText = "Start (Trigger Mode)";
        btnReset.classList.add('d-none');
        document.getElementById('btn-download').disabled = true;
    } else if (state === 'ARMED') {
        badge.innerText = `WAITING (> ${triggerThresh} m/s²)`;
        badge.className = "status-badge bg-waiting";
        btnStart.classList.add('d-none');
        btnReset.classList.remove('d-none');
        btnReset.innerText = "Cancel";
        document.getElementById('btn-download').disabled = true;
    } else if (state === 'RECORDING') {
        badge.innerText = "RECORDING...";
        badge.className = "status-badge bg-recording";
        // Buttons hidden during recording
        btnStart.classList.add('d-none');
        btnReset.classList.add('d-none');
    } else if (state === 'REVIEW') {
        badge.innerText = "FINISHED (FROZEN)";
        badge.className = "status-badge bg-review";
        btnStart.classList.add('d-none');
        btnReset.classList.remove('d-none');
        btnReset.innerText = "Reset / Monitor"; // ここで再開できることを明示
    }
}

function changeAxis(axis) {
    currentAxis = axis;
    // REVIEWモード(停止中)でも、軸を切り替えたら再描画して確認できるようにする
    if (state === 'REVIEW') {
        drawCharts();
    }
}

document.getElementById('btn-trigger-start').addEventListener('click', () => {
    triggerThresh = parseFloat(document.getElementById('trigger-threshold').value);
    recDurationMs = parseFloat(document.getElementById('record-duration').value) * 1000;
    state = 'ARMED';
    updateStatusUI();
});

document.getElementById('btn-reset').addEventListener('click', () => {
    // どんな状態からでもモニタリング(IDLE)に戻るボタン
    state = 'IDLE';
    updateStatusUI();
});

document.getElementById('btn-calibrate').addEventListener('click', () => {
    // データが十分に溜まっているか確認
    if(displayBuffer.z.length > 50) { // 50個以上のデータを使う
        const len = displayBuffer.z.length;
        
        // 直近50個のデータの平均値を計算
        let sumX = 0, sumY = 0, sumZ = 0;
        const count = 50;
        for(let i = 0; i < count; i++) {
            sumX += displayBuffer.x[len - 1 - i];
            sumY += displayBuffer.y[len - 1 - i];
            sumZ += displayBuffer.z[len - 1 - i];
        }

        // 現在のオフセットに「ズレの平均」を足し合わせる
        offsets.x += (sumX / count);
        offsets.y += (sumY / count);
        offsets.z += (sumZ / count);

        alert("平均値でゼロ点調整しました。\n(Precision Calibrated)");
    } else {
        alert("データ収集中です...もう少し待ってから押してください");
    }
});

document.getElementById('btn-download').addEventListener('click', () => {
    if (recordBuffer.length === 0) return;
    let csv = "Time_ms,X,Y,Z\n" + recordBuffer.map(r => r.join(",")).join("\n");
    const link = document.createElement("a");
    link.href = encodeURI("data:text/csv;charset=utf-8," + csv);
    link.download = `vib_data_${Date.now()}.csv`;
    document.body.appendChild(link); link.click(); document.body.removeChild(link);
});

// --- Sensor ---
function startSensor() {
    if ('LinearAccelerationSensor' in window) {
        try {
            const s = new LinearAccelerationSensor({ frequency: 60 });
            s.addEventListener('reading', () => handleSensorData(s.x, s.y, s.z, performance.now()));
            s.start();
        } catch(e) { fallbackSensor(); }
    } else { fallbackSensor(); }
}

function fallbackSensor() {
    window.addEventListener('devicemotion', (e) => {
        const acc = e.acceleration || e.accelerationIncludingGravity;
        handleSensorData(acc.x||0, acc.y||0, acc.z||0, performance.now());
    });
}

startSensor();

</script>
</body>
</html>